# Prompt: Iterative Implementation (Task-by-Task Coding)

**Persona:** Specialist Developer
**Phase:** 2 - Implementation
**Purpose:** Implement one specific task from the task list

---

## When to Use This Prompt

✅ **Use when:**
- You have a task list
- You're ready to implement one specific task
- You want code for a single, focused change

❌ **Don't use when:**
- You don't have a task list (generate one first)
- You want to implement multiple tasks at once (do one at a time!)
- You want to review code (use Phase 3 prompts)

---

## The Critical Rule: ONE TASK AT A TIME

This is the **most important prompt** in the entire workflow. Use it for **every single task** on your task list.

**Why one task at a time?**
- Easier to review
- Easier to test
- Easier to debug
- Forces incremental progress
- Prevents scope creep

---

## The Prompt Template

```markdown
You are an expert **[Language/Framework]** developer.
Example: "You are an expert **Python/FastAPI** developer"
Example: "You are an expert **TypeScript/React** developer"

**Your Context:**

1. **Constitution:** You MUST follow all rules in the attached `CONSTITUTION.md`

2. **Task List:** We are working on **Task #[NUMBER]** from the task list

3. **Task Description:**
   [Paste the exact task description from your task list]

4. **Relevant Code:** Here is the existing code you may need to modify or reference:
   [Attach all relevant files]

**Your Assignment:**

1. Write the code to complete **ONLY** the task described above
2. Do NOT implement any other tasks from the list
3. Explain your code step-by-step, including **why** you made certain decisions
4. Include clear comments in the code as specified by CONSTITUTION.md
5. Handle errors properly (as specified in CONSTITUTION.md)
6. If the task requires creating a new file, provide the complete file
7. If the task requires modifying an existing file, show the exact changes (before/after)

**Additional Requirements:**
- Follow existing code patterns in the codebase
- Adhere to naming conventions from CONSTITUTION.md
- Add meaningful comments (explain "why", not "what")
- Include error handling
- Do not use any prohibited technologies from CONSTITUTION.md

---

**Files to Attach:**
- `CONSTITUTION.md`
- `docs/[feature-name]-tasks.md` (for context)
- All relevant code files (existing code this task will touch)
```

---

## How to Use This Prompt

### Step 1: Identify the Task

From your task list, choose the next task to implement (usually Task #1, then #2, etc.)

### Step 2: Gather Context

Collect:
- [ ] `CONSTITUTION.md`
- [ ] The task list file
- [ ] All code files mentioned in the task
- [ ] Related code files (for context)

### Step 3: Fill in the Template

- Replace `[Language/Framework]` with your stack (e.g., "Python/FastAPI")
- Replace `[NUMBER]` with the task number
- Paste the exact task description
- Attach all relevant files

### Step 4: Invoke the AI

Paste the filled prompt.

### Step 5: Review the Generated Code

Check for:
- [ ] Does it implement ONLY this task (not other tasks)?
- [ ] Does it follow CONSTITUTION.md standards?
- [ ] Are comments meaningful?
- [ ] Is error handling present?
- [ ] Does it match existing code patterns?
- [ ] Can you understand the code without asking questions?

### Step 6: Test the Code

- [ ] Copy the code into your project
- [ ] Run linters/formatters
- [ ] Run tests (unit tests if available)
- [ ] Manually test the functionality

### Step 7: Commit (Optional)

```bash
git add [files]
git commit -m "feat: [task description]"
```

### Step 8: Move to Next Task

Repeat this process for Task #2, #3, etc. until all tasks are complete.

---

## Example Input

````markdown
You are an expert **Python/FastAPI** developer.

**Your Context:**

1. **Constitution:** (attached: CONSTITUTION.md)

2. **Task List:** We are working on **Task #5** from the task list

3. **Task Description:**
   ```
   Task 5: Implement createResetToken method
   Description: Implement the password reset request logic
   Files to MODIFY: src/services/password-reset.service.ts
   What to do:
   - Look up user by email (use existing UserModel.findByEmail)
   - If user doesn't exist, return early (don't error - security)
   - Check rate limit: Max 3 requests per email per hour
   - Generate token using TokenGenerator
   - Hash token
   - Calculate expiry (1 hour from now)
   - Save to database
   - Queue email (use background task)
   - Add error handling
   - Add method JSDoc
   ```

4. **Relevant Code:**
   [Attach these files:]
   - src/services/password-reset.service.ts (the file to modify)
   - src/models/user.model.ts (for UserModel.findByEmail)
   - src/utils/token-generator.ts (for TokenGenerator)
   - src/services/email.service.ts (for sending email)
   - CONSTITUTION.md
````

---

## Example Output (What the Developer Should Generate)

````markdown
I'll implement the `createResetToken` method for the PasswordResetService. Here's my step-by-step approach:

## Step 1: Method Structure

I'm adding this method to `PasswordResetService` class. This method handles the password reset request flow.

```python
async def createResetToken(self, email: str) -> None:
    """
    Create a password reset token and send reset email to user.

    This method implements a security-conscious password reset flow:
    - Always returns successfully to prevent email enumeration attacks
    - Enforces rate limiting to prevent abuse
    - Uses cryptographically secure tokens with 1-hour expiration

    Args:
        email: User's email address

    Raises:
        RateLimitError: If user has exceeded max reset requests per hour

    Security Notes:
        - Tokens are hashed before storage (never stored in plain text)
        - Email sending happens in background to avoid blocking
        - Returns success even if email doesn't exist (prevents enumeration)
    """
```

## Step 2: Look Up User (Security-Conscious)

```python
    # Look up user by email
    user = await UserModel.findByEmail(email)

    # Security: If user doesn't exist, return early without error
    # This prevents attackers from discovering valid email addresses
    if not user:
        logger.info(f"Password reset requested for non-existent email: {email[:3]}***")
        return  # Silently succeed to prevent email enumeration
```

**Why I did this:**
- We return early if user doesn't exist, but don't throw an error
- This prevents attackers from using this endpoint to discover which emails are registered
- We log the attempt but mask the email for privacy

## Step 3: Rate Limiting Check

```python
    # Check rate limit: Max 3 requests per email per hour
    one_hour_ago = datetime.now() - timedelta(hours=1)

    recent_tokens = await self.db.query(PasswordResetToken).filter(
        PasswordResetToken.user_id == user.id,
        PasswordResetToken.created_at >= one_hour_ago
    ).count()

    if recent_tokens >= 3:
        logger.warning(f"Rate limit exceeded for user {user.id}")
        raise RateLimitError(
            code="RATE_LIMIT_EXCEEDED",
            message="Too many password reset requests. Please try again in 1 hour."
        )
```

**Why I did this:**
- Prevents abuse (someone spamming reset requests)
- Queries database for tokens created in last hour
- Raises custom error if limit exceeded (HTTP 429 will be returned by API layer)

## Step 4: Generate and Hash Token

```python
    # Generate cryptographically secure token
    token = self.token_generator.generate()  # 32-byte hex string
    token_hash = self.token_generator.hash(token)  # Bcrypt hash

    # Calculate expiry (1 hour from now)
    expires_at = datetime.now() + timedelta(hours=1)
```

**Why I did this:**
- Use TokenGenerator (injected dependency) for token creation
- Hash the token before storing (if DB is compromised, tokens are useless)
- 1-hour expiry balances security (short window) and UX (reasonable time to act)

## Step 5: Save to Database

```python
    # Save token to database
    try:
        reset_token = PasswordResetToken(
            user_id=user.id,
            token_hash=token_hash,
            created_at=datetime.now(),
            expires_at=expires_at,
            used_at=None
        )
        await self.db.add(reset_token)
        await self.db.commit()

    except Exception as e:
        logger.error(f"Failed to save password reset token: {e}")
        await self.db.rollback()
        raise DatabaseError(
            code="DATABASE_ERROR",
            message="Failed to create password reset token. Please try again."
        )
```

**Why I did this:**
- Wrap in try/except to handle database errors gracefully
- Rollback on error to maintain data integrity
- Log the error for debugging but show user-friendly message

## Step 6: Send Email (Background Task)

```python
    # Queue password reset email (non-blocking)
    try:
        background_tasks = BackgroundTasks()
        background_tasks.add_task(
            self.email_service.sendPasswordResetEmail,
            email=user.email,
            token=token,  # Send plain token (not hash) in email
            user_name=user.name
        )
        logger.info(f"Password reset email queued for user {user.id}")

    except Exception as e:
        # Log email error but don't fail the request
        # User will still get success message (token is already saved)
        logger.error(f"Failed to queue password reset email: {e}")
        # We don't raise here - token is created, email failure shouldn't block user
```

**Why I did this:**
- Use background task so email sending doesn't block the API response
- Send the plain token in the email (not the hash)
- If email fails, we log it but don't fail the entire request (token is already saved)

## Complete Method

Here's the complete method:

```python
async def createResetToken(self, email: str) -> None:
    """
    Create a password reset token and send reset email to user.

    ... [docstring as shown above] ...
    """
    # 1. Look up user
    user = await UserModel.findByEmail(email)
    if not user:
        logger.info(f"Password reset requested for non-existent email: {email[:3]}***")
        return

    # 2. Check rate limit
    one_hour_ago = datetime.now() - timedelta(hours=1)
    recent_tokens = await self.db.query(PasswordResetToken).filter(
        PasswordResetToken.user_id == user.id,
        PasswordResetToken.created_at >= one_hour_ago
    ).count()

    if recent_tokens >= 3:
        logger.warning(f"Rate limit exceeded for user {user.id}")
        raise RateLimitError(
            code="RATE_LIMIT_EXCEEDED",
            message="Too many password reset requests. Please try again in 1 hour."
        )

    # 3. Generate token
    token = self.token_generator.generate()
    token_hash = self.token_generator.hash(token)
    expires_at = datetime.now() + timedelta(hours=1)

    # 4. Save to database
    try:
        reset_token = PasswordResetToken(
            user_id=user.id,
            token_hash=token_hash,
            created_at=datetime.now(),
            expires_at=expires_at,
            used_at=None
        )
        await self.db.add(reset_token)
        await self.db.commit()
    except Exception as e:
        logger.error(f"Failed to save password reset token: {e}")
        await self.db.rollback()
        raise DatabaseError(
            code="DATABASE_ERROR",
            message="Failed to create password reset token. Please try again."
        )

    # 5. Queue email
    try:
        background_tasks = BackgroundTasks()
        background_tasks.add_task(
            self.email_service.sendPasswordResetEmail,
            email=user.email,
            token=token,
            user_name=user.name
        )
        logger.info(f"Password reset email queued for user {user.id}")
    except Exception as e:
        logger.error(f"Failed to queue password reset email: {e}")
```

## Summary of Design Decisions

1. **Security-first approach:**
   - Token hashing (prevents DB compromise attack)
   - Email enumeration prevention (return success even if email doesn't exist)
   - Rate limiting (prevents abuse)

2. **Error handling:**
   - Database errors are caught and rolled back
   - Email failures are logged but don't block the flow
   - User-friendly error messages (no stack traces exposed)

3. **Performance:**
   - Background task for email (non-blocking)
   - Database query uses indexes (user_id, created_at)

4. **Maintainability:**
   - Clear docstring explaining the method
   - Comments explain "why", not "what"
   - Follows existing patterns in the codebase

**Task #5 is now complete.**
````

---

## Common Pitfalls to Avoid

### ❌ Implementing Multiple Tasks
**Bad:** "Also, I added the verify token method while I was at it..."
**Good:** "This completes Task #5. Task #6 (verify token) is next."

### ❌ Deviating from the Task
**Bad:** "I think it would be better to use Redis instead of PostgreSQL..."
**Good:** Follow the tech spec exactly; raise concerns separately

### ❌ No Explanation
**Bad:** Just dumping code without context
**Good:** Explaining step-by-step with reasoning

### ❌ Missing Error Handling
**Bad:** No try/catch blocks
**Good:** Comprehensive error handling for every external call

### ❌ Redundant Comments
**Bad:** `# Loop through users`
**Good:** `# Filter out inactive users to reduce email volume`

---

## Tips for Better Implementations

### ✅ DO:
- Explain your reasoning
- Handle all possible errors
- Add meaningful comments
- Follow existing patterns
- Use descriptive variable names
- Test after implementing

### ❌ DON'T:
- Implement multiple tasks at once
- Skip error handling
- Write redundant comments
- Ignore CONSTITUTION.md
- Use prohibited technologies
- Over-engineer

---

## After Implementation Checklist

Before moving to the next task:

- [ ] Code implements exactly this task (no more, no less)
- [ ] Code follows CONSTITUTION.md standards
- [ ] Comments are meaningful (explain "why")
- [ ] Error handling is comprehensive
- [ ] Code matches existing patterns
- [ ] You understand every line
- [ ] Code passes linting
- [ ] Tests pass (if you have them)
- [ ] You manually tested it

---

## Next Steps

1. **Review** the generated code
2. **Test** the implementation
3. **Commit** (optional):
   ```bash
   git add [files]
   git commit -m "feat(auth): implement createResetToken method (#5)"
   ```
4. **Move to next task:** Repeat this prompt for Task #6

---

## Related Resources

- [Specialist Developer Persona](../../personas/03-specialist-developer.md)
- Previous: [Generate Task List](./2.1-generate-task-list.md)
- Next: [Code Commenter](./2.3-code-commenter.md) or [QA Review](../phase-3-review/3.1-qa-comprehensive-review.md)
