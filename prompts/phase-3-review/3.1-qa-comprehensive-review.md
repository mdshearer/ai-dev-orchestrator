# Prompt: QA Comprehensive Code Review

**Persona:** QA Engineer
**Phase:** 3 - Review and Refactoring
**Purpose:** Holistic code review across all quality dimensions

---

## When to Use This Prompt

‚úÖ **Use when:**
- You've completed a feature or task
- You want broad feedback before merging
- You need a general quality check
- You're preparing for a pull request

‚ùå **Don't use when:**
- You want deep analysis of one specific aspect (use specialized prompts)
- You haven't written code yet
- You want to refactor (use architect consultation prompt)

---

## The 5 Dimensions of Code Quality

This comprehensive review covers ALL five dimensions:

1. **Code Quality & Best Practices**
2. **Potential Bugs or Edge Cases**
3. **Performance Optimizations**
4. **Readability & Maintainability**
5. **Security Concerns**

---

## The Prompt Template

```markdown
You are a Senior QA Engineer. Please review the following code:

[Paste or attach your code]

**Rules:**
1. You MUST check for violations against the attached `CONSTITUTION.md`
2. You MUST explain your reasoning for every suggestion
3. Provide specific file names and line numbers for all issues
4. Categorize issues by severity: CRITICAL, HIGH, MEDIUM, LOW

**Review Dimensions:**
Consider the following 5 dimensions of code quality:

1. **Code Quality & Best Practices**
   - Adherence to standards (CONSTITUTION.md)
   - Code smells and anti-patterns
   - DRY (Don't Repeat Yourself)
   - SOLID principles
   - Naming conventions

2. **Potential Bugs or Edge Cases**
   - Logic flaws
   - Off-by-one errors
   - Null/undefined handling
   - Empty collections
   - Boundary conditions
   - Race conditions

3. **Performance Optimizations**
   - N+1 query problems
   - Inefficient loops or algorithms
   - Unnecessary re-renders (frontend)
   - Missing database indexes
   - Memory leaks
   - Blocking operations

4. **Readability & Maintainability**
   - Code complexity
   - Function length
   - Nested conditions
   - Magic numbers/strings
   - Comment quality
   - Code duplication

5. **Security Concerns**
   - SQL injection
   - XSS (Cross-Site Scripting)
   - Authentication/authorization flaws
   - Sensitive data exposure
   - Insecure dependencies
   - Missing input validation

**Output Format:**
Provide a structured review addressing each dimension separately. For each issue:
- Severity level
- File and line number
- Clear description
- Why it's an issue
- Suggested fix (with code example if possible)

Also identify **strengths** (what was done well).

---

**Files to Attach:**
- Your code to review
- `CONSTITUTION.md`
- (Optional) Related code for context
```

---

## How to Use This Prompt

### Step 1: Prepare Your Code

- [ ] Code is complete (at least for the task)
- [ ] You've tested it manually
- [ ] It runs without errors

### Step 2: Attach Files

- [ ] The code to review
- [ ] `CONSTITUTION.md`
- [ ] Related files (for context)

### Step 3: Invoke the AI

Paste the prompt with code attached.

### Step 4: Review the Feedback

The QA Engineer will provide:
- Overall assessment
- Issues by dimension
- Severity levels
- Specific recommendations

### Step 5: Address Issues

Prioritize fixes:
1. **CRITICAL** - Fix immediately
2. **HIGH** - Fix before merging
3. **MEDIUM** - Fix in this iteration
4. **LOW** - Fix when convenient

### Step 6: Re-review (Optional)

After fixes, you can run the review again to verify improvements.

---

## Example Input

```python
# password_reset.py

def create_reset_token(email):
    user = db.query("SELECT * FROM users WHERE email = '" + email + "'")

    if user:
        token = str(random.randint(100000, 999999))
        db.execute("INSERT INTO reset_tokens VALUES ('" + token + "', '" + user.id + "')")
        send_email(email, token)
        return {"message": "Reset email sent"}
    else:
        return {"error": "Email not found"}
```

---

## Example Output (What the QA Engineer Should Generate)

```markdown
# Code Review: password_reset.py

## Overall Assessment: NEEDS SIGNIFICANT IMPROVEMENT

This code has **critical security vulnerabilities** and multiple quality issues that must be addressed before deployment.

---

## üî¥ CRITICAL ISSUES (Fix Immediately)

### 1. SQL Injection Vulnerability

**Dimension:** Security Concerns
**Location:** Line 4
**Severity:** CRITICAL

**Issue:**
```python
user = db.query("SELECT * FROM users WHERE email = '" + email + "'")
```

User input is directly concatenated into SQL query. An attacker can inject malicious SQL.

**Attack Example:**
```python
email = "'; DROP TABLE users; --"
# Results in: SELECT * FROM users WHERE email = ''; DROP TABLE users; --'
```

**Fix:**
Use parameterized queries:
```python
user = db.query("SELECT * FROM users WHERE email = ?", (email,))
# Or with ORM:
user = db.query(User).filter(User.email == email).first()
```

**Why this matters:** This could lead to complete database compromise.

---

### 2. Weak Password Reset Token

**Dimension:** Security Concerns
**Location:** Line 7
**Severity:** CRITICAL

**Issue:**
```python
token = str(random.randint(100000, 999999))
```

Token is only 6 digits (1 million possibilities). Attacker can brute force in minutes.

**Fix:**
Use cryptographically secure random token:
```python
import secrets
token = secrets.token_urlsafe(32)  # 256 bits of randomness
```

**Why this matters:** Weak tokens can be guessed, allowing account takeover.

---

### 3. Plain Text Token Storage

**Dimension:** Security Concerns
**Location:** Line 8
**Severity:** CRITICAL

**Issue:**
```python
db.execute("INSERT INTO reset_tokens VALUES ('" + token + "', '" + user.id + "')")
```

Token is stored in plain text. If database is compromised, attacker can reset any password.

**Fix:**
Hash the token before storage:
```python
import bcrypt
token_hash = bcrypt.hashpw(token.encode(), bcrypt.gensalt())
db.execute("INSERT INTO reset_tokens VALUES (?, ?)", (token_hash, user.id))
```

---

## üü† HIGH ISSUES (Fix Before Merging)

### 4. Email Enumeration

**Dimension:** Security Concerns
**Location:** Lines 12-13
**Severity:** HIGH

**Issue:**
```python
return {"error": "Email not found"}
```

Revealing whether email exists allows attackers to discover registered users.

**Fix:**
Always return success:
```python
# Always return success to prevent email enumeration
return {"message": "If that email exists, a reset link has been sent"}
```

---

### 5. No Rate Limiting

**Dimension:** Security Concerns
**Location:** Entire function
**Severity:** HIGH

**Issue:**
No rate limiting. Attacker can spam reset requests or brute force tokens.

**Fix:**
Add rate limiting:
```python
# Check if user has exceeded max requests (e.g., 3 per hour)
recent_requests = count_recent_requests(email, hours=1)
if recent_requests >= 3:
    raise RateLimitError("Too many requests. Try again in 1 hour.")
```

---

### 6. No Error Handling

**Dimension:** Code Quality & Best Practices
**Location:** Entire function
**Severity:** HIGH

**Issue:**
No try/except blocks. Any error (DB failure, email failure) will crash.

**Fix:**
```python
try:
    # ... code here ...
except DatabaseError as e:
    logger.error(f"Database error in password reset: {e}")
    return {"error": "Server error. Please try again."}
except EmailError as e:
    logger.error(f"Email error: {e}")
    # Don't fail if email fails - token is already created
```

---

## üü° MEDIUM ISSUES (Fix This Iteration)

### 7. Missing Input Validation

**Dimension:** Potential Bugs
**Location:** Line 3 (function start)
**Severity:** MEDIUM

**Issue:**
No validation of email format. Could cause downstream errors.

**Fix:**
```python
import re
EMAIL_REGEX = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
if not re.match(EMAIL_REGEX, email):
    return {"error": "Invalid email format"}
```

---

### 8. No Function Documentation

**Dimension:** Readability & Maintainability
**Location:** Function definition
**Severity:** MEDIUM

**Issue:**
Function has no docstring. Purpose, parameters, and return values are unclear.

**Fix:**
```python
def create_reset_token(email: str) -> dict:
    """
    Create a password reset token and send it via email.

    Args:
        email: User's email address

    Returns:
        dict: Success or error message

    Raises:
        RateLimitError: If user has exceeded max requests per hour
    """
```

---

### 9. Missing Token Expiration

**Dimension:** Security Concerns
**Location:** Line 8
**Severity:** MEDIUM

**Issue:**
Tokens never expire. Old tokens remain valid forever.

**Fix:**
```python
expires_at = datetime.now() + timedelta(hours=1)
db.execute("INSERT INTO reset_tokens VALUES (?, ?, ?)",
           (token_hash, user.id, expires_at))
```

---

## üü¢ LOW ISSUES (Fix When Convenient)

### 10. Magic String in Response

**Dimension:** Code Quality & Best Practices
**Location:** Line 10
**Severity:** LOW

**Issue:**
Hard-coded string "Reset email sent". Should be a constant.

**Fix:**
```python
SUCCESS_MESSAGE = "If that email exists, a reset link has been sent"
return {"message": SUCCESS_MESSAGE}
```

---

## ‚úÖ STRENGTHS

What was done well:
1. Function has a clear, single purpose (password reset)
2. Simple, easy-to-follow logic flow
3. Returns consistent JSON response format

---

## SUMMARY

**Total Issues:** 10
- Critical: 3
- High: 3
- Medium: 3
- Low: 1

**Recommendation:** This code is **NOT ready for production**. Address all CRITICAL and HIGH issues before deployment.

**Estimated Fix Time:** 2-3 hours
```

---

## Severity Level Guide

### üî¥ CRITICAL
- Security vulnerabilities
- Data loss or corruption
- Application crashes
- **Action:** Fix before deploying

### üü† HIGH
- Bugs affecting core functionality
- Major performance issues
- Missing critical error handling
- **Action:** Fix before merging

### üü° MEDIUM
- Edge case bugs
- Code quality issues
- Non-critical optimizations
- **Action:** Fix this iteration

### üü¢ LOW
- Minor style issues
- Small optimizations
- Nitpicks
- **Action:** Fix when convenient

---

## Tips for Better Reviews

### ‚úÖ DO:
- Read the entire review carefully
- Fix CRITICAL and HIGH issues immediately
- Ask questions if you don't understand feedback
- Learn from the issues (avoid repeating)

### ‚ùå DON'T:
- Ignore CRITICAL issues
- Argue without understanding
- Fix issues without testing
- Skip re-testing after fixes

---

## After Review Checklist

- [ ] All CRITICAL issues fixed
- [ ] All HIGH issues fixed
- [ ] MEDIUM issues fixed or scheduled
- [ ] Code re-tested after fixes
- [ ] Linters/formatters pass
- [ ] Tests still pass
- [ ] (Optional) Re-run review to verify

---

## Next Steps

After addressing issues:

1. **For minor issues:** Move to Phase 4 (Documentation)
2. **For major refactoring:** Use [3.6-architect-refactor-consultation.md](./3.6-architect-refactor-consultation.md)
3. **For specific concerns:** Use specialized review prompts (3.2-3.5)

---

## Related Resources

- [QA Engineer Persona](../../personas/04-qa-engineer.md)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- Previous: [Code Commenter](../phase-2-implementation/2.3-code-commenter.md)
- Next: [Specialized Reviews](./3.2-qa-bugs-edge-cases.md) or [Documentation](../phase-4-documentation/4.1-readme-generator.md)
