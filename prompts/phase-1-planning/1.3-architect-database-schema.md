# Prompt: Solutions Architect - Database Schema Design

**Persona:** Solutions Architect
**Phase:** 1 - Planning and Design (Specialized)
**Purpose:** Design a complete, production-ready database schema

---

## When to Use This Prompt

✅ **Use when:**
- Your tech spec requires new database tables
- The data model is complex and needs focused design
- You want to validate database structure before implementation

❌ **Don't use when:**
- The tech spec already has sufficient database details
- The feature doesn't touch the database
- You're just adding a column to an existing table (modify existing schema instead)

---

## The Prompt Template

```markdown
You are a Senior Database Architect. I need to design the database schema for the feature described in the attached tech spec.

**Business Context:**
[Describe the domain/problem this database will support]

**High-Level Entities:**
[List the main entities and their key fields]

Example:
* **User:** [id, email, name, created_at]
* **Project:** [id, user_id, title, description]
* **Task:** [id, project_id, title, status, due_date]

**Rules & Constraints:**
1. This is for an [internal tool / web app / API / etc.] - do not over-engineer
2. Use **[PostgreSQL / MySQL / MongoDB / etc.]** syntax (as specified in `CONSTITUTION.md`)
3. Use **UUIDs** for all primary keys (or specify your ID strategy)
4. **Do not create additional entities** other than what is defined above
5. Ensure all foreign key relationships are defined
6. Create indexes for:
   - All foreign keys
   - Commonly queried fields (specify which)
7. Add appropriate constraints (NOT NULL, UNIQUE, CHECK constraints)
8. Follow naming conventions from `CONSTITUTION.md`

**Your Task:**
Generate complete, production-ready SQL code for:

1. **Database Creation** (if applicable)
2. **Table Schemas**
   - Include `DROP TABLE IF EXISTS` statements (for repeatability)
   - Define all columns with appropriate types
   - Define all constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK)
   - Add comments explaining design decisions
3. **Indexes**
   - Create indexes on foreign keys
   - Create indexes on commonly queried columns
4. **Sample Test Data**
   - Insert 3 rows of realistic test data for each table
   - Ensure foreign key relationships are correctly linked

**Output Format:**
- Single SQL file
- Well-commented
- Runnable as-is

---

**Files to Attach:**
- `[feature-name]-tech-spec.md` (the feature being implemented)
- `CONSTITUTION.md` (for database standards)
- `database/schema.sql` (existing schema, for context)
```

---

## How to Use This Prompt

### Step 1: Define Your Entities

List all entities (tables) needed. For each entity, list key fields.

Example:
```
* User: id, email, password_hash, created_at
* PasswordResetToken: id, user_id, token_hash, expires_at, used_at
```

### Step 2: Describe Business Context

Explain what problem the database solves:
- "This supports a password reset system for internal users"
- "This tracks customer orders and inventory"

### Step 3: Specify Constraints

Tell the architect:
- [ ] What database system? (PostgreSQL, MySQL, etc.)
- [ ] What ID strategy? (UUIDs, auto-increment integers)
- [ ] What should be indexed?
- [ ] Any unique constraints? (e.g., email must be unique)
- [ ] Any check constraints? (e.g., quantity > 0)

### Step 4: Invoke the AI

Paste the filled prompt with attached files.

### Step 5: Review the Schema

Check for:
- [ ] Correct data types
- [ ] All foreign keys defined
- [ ] Indexes on the right columns
- [ ] Appropriate constraints (NOT NULL, UNIQUE)
- [ ] No over-normalization or under-normalization
- [ ] Follows naming conventions

### Step 6: Test the SQL

- [ ] Copy the generated SQL
- [ ] Run it in a test database
- [ ] Verify tables are created correctly
- [ ] Verify test data inserts successfully

---

## Example Input

```markdown
**Business Context:**
This database supports a password reset feature for an internal employee portal. Users can request password resets, which generate time-limited tokens sent via email.

**High-Level Entities:**
* **User:** [id, email, password_hash, name, created_at, updated_at]
* **PasswordResetToken:** [id, user_id, token_hash, created_at, expires_at, used_at]

**Rules & Constraints:**
1. This is for an internal tool - do not over-engineer
2. Use **PostgreSQL** syntax
3. Use **UUIDs** for all primary keys
4. Do not create additional entities
5. Ensure all foreign key relationships are defined
6. Create indexes for:
   - All foreign keys
   - `users.email` (frequently queried for lookups)
   - `password_reset_tokens.token_hash` (queried for validation)
7. Constraints:
   - `users.email` must be unique
   - `password_reset_tokens.expires_at` must be after `created_at`
   - `password_reset_tokens.token_hash` must be unique
```

---

## Example Output (What the Architect Should Generate)

```sql
-- ============================================
-- Password Reset Feature - Database Schema
-- Database: PostgreSQL 15+
-- ============================================

-- Enable UUID extension (if not already enabled)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- TABLE: users
-- ============================================
-- Stores user account information
-- Note: This table may already exist; shown here for completeness

DROP TABLE IF EXISTS password_reset_tokens CASCADE;
DROP TABLE IF EXISTS users CASCADE;

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CONSTRAINT email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);

-- Comments
COMMENT ON TABLE users IS 'User accounts for the application';
COMMENT ON COLUMN users.password_hash IS 'Bcrypt-hashed password (never store plain text)';

-- ============================================
-- TABLE: password_reset_tokens
-- ============================================
-- Stores time-limited password reset tokens
-- Tokens are single-use and expire after 1 hour

CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    token_hash VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP NULL,

    -- Foreign Keys
    CONSTRAINT fk_password_reset_tokens_user
        FOREIGN KEY (user_id)
        REFERENCES users(id)
        ON DELETE CASCADE,  -- If user is deleted, delete their reset tokens

    -- Check Constraints
    CONSTRAINT token_expiry_valid
        CHECK (expires_at > created_at)
);

-- Indexes
CREATE INDEX idx_password_reset_tokens_user_id ON password_reset_tokens(user_id);
CREATE INDEX idx_password_reset_tokens_token_hash ON password_reset_tokens(token_hash);
CREATE INDEX idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);

-- Comments
COMMENT ON TABLE password_reset_tokens IS 'Time-limited password reset tokens sent via email';
COMMENT ON COLUMN password_reset_tokens.token_hash IS 'Hashed version of reset token (never store plain tokens)';
COMMENT ON COLUMN password_reset_tokens.used_at IS 'Timestamp when token was used (NULL if unused)';

-- ============================================
-- SAMPLE TEST DATA
-- ============================================

-- Insert test users
INSERT INTO users (id, email, password_hash, name) VALUES
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'alice@company.com', '$2b$10$EixZaYVK1fsbw1ZfbX3OXe.PBITdl0pN5xtQCz9HZXB5EpLc2M7Gi', 'Alice Johnson'),
    ('b1ffcd11-1d1c-5fg9-cc7e-7cc0ce491b22', 'bob@company.com', '$2b$10$EixZaYVK1fsbw1ZfbX3OXe.PBITdl0pN5xtQCz9HZXB5EpLc2M7Gi', 'Bob Smith'),
    ('c2ggde22-2e2d-6gh0-dd8f-8dd1df502c33', 'carol@company.com', '$2b$10$EixZaYVK1fsbw1ZfbX3OXe.PBITdl0pN5xtQCz9HZXB5EpLc2M7Gi', 'Carol Davis');

-- Insert test password reset tokens
INSERT INTO password_reset_tokens (user_id, token_hash, created_at, expires_at, used_at) VALUES
    -- Active token (not used, not expired)
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
     '$2b$10$ABC123XYZ789...',
     CURRENT_TIMESTAMP,
     CURRENT_TIMESTAMP + INTERVAL '1 hour',
     NULL),

    -- Used token
    ('b1ffcd11-1d1c-5fg9-cc7e-7cc0ce491b22',
     '$2b$10$DEF456UVW012...',
     CURRENT_TIMESTAMP - INTERVAL '2 hours',
     CURRENT_TIMESTAMP - INTERVAL '1 hour',
     CURRENT_TIMESTAMP - INTERVAL '1 hour 30 minutes'),

    -- Expired token (not used, but expired)
    ('c2ggde22-2e2d-6gh0-dd8f-8dd1df502c33',
     '$2b$10$GHI789RST345...',
     CURRENT_TIMESTAMP - INTERVAL '3 hours',
     CURRENT_TIMESTAMP - INTERVAL '2 hours',
     NULL);

-- ============================================
-- VERIFICATION QUERIES
-- ============================================
-- Run these to verify the schema

-- Check tables exist
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN ('users', 'password_reset_tokens');

-- Check foreign keys
SELECT
    tc.table_name,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY';

-- Check indexes
SELECT tablename, indexname, indexdef
FROM pg_indexes
WHERE schemaname = 'public'
AND tablename IN ('users', 'password_reset_tokens');
```

---

## Common Database Design Patterns

### Pattern 1: Soft Delete
Instead of deleting records, mark them as deleted:
```sql
ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP NULL;
CREATE INDEX idx_users_deleted_at ON users(deleted_at);
```

### Pattern 2: Audit Trail
Track who created/modified records:
```sql
ALTER TABLE projects ADD COLUMN created_by UUID REFERENCES users(id);
ALTER TABLE projects ADD COLUMN updated_by UUID REFERENCES users(id);
```

### Pattern 3: Timestamps (Always)
Every table should have:
```sql
created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
```

### Pattern 4: Enum with CHECK Constraint
For status fields:
```sql
status VARCHAR(20) NOT NULL DEFAULT 'pending',
CONSTRAINT status_valid CHECK (status IN ('pending', 'active', 'completed', 'cancelled'))
```

---

## Tips for Better Database Schemas

### ✅ DO:
- Use UUIDs for public-facing IDs (prevents enumeration)
- Index foreign keys (performance)
- Index frequently queried columns
- Use NOT NULL where appropriate
- Add CHECK constraints for data validation
- Use CASCADE carefully (understand implications)
- Add comments explaining design decisions

### ❌ DON'T:
- Over-normalize (too many joins hurt performance)
- Under-normalize (data duplication and inconsistency)
- Use VARCHAR without length (specify max length)
- Forget indexes on foreign keys
- Store computed values (calculate on query instead)
- Use reserved keywords as column names

---

## Testing Your Schema

After generation, run these checks:

```sql
-- 1. Test foreign key constraints
-- Try to insert invalid user_id (should fail)
INSERT INTO password_reset_tokens (user_id, token_hash, expires_at)
VALUES ('00000000-0000-0000-0000-000000000000', 'test', CURRENT_TIMESTAMP);

-- 2. Test unique constraints
-- Try to insert duplicate email (should fail)
INSERT INTO users (email, password_hash, name)
VALUES ('alice@company.com', 'hash', 'Duplicate Alice');

-- 3. Test check constraints
-- Try to create token with expires_at before created_at (should fail)
INSERT INTO password_reset_tokens (user_id, token_hash, created_at, expires_at)
VALUES ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'test', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP - INTERVAL '1 hour');

-- 4. Verify indexes exist
\d+ users
\d+ password_reset_tokens
```

---

## Next Steps After Schema Approval

1. **Save the SQL** to `database/migrations/[NNN]_[feature-name].sql`
2. **Run it** in your development database
3. **Update your ORM models** (if using an ORM)
4. **Continue with tech spec** or move to implementation

---

## Related Resources

- [Solutions Architect Persona](../../personas/02-solutions-architect.md)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Database Normalization Guide](https://en.wikipedia.org/wiki/Database_normalization)
- Previous: [Tech Spec](./1.2-architect-tech-spec.md)
- Next: [API Design](./1.4-architect-api-design.md)
