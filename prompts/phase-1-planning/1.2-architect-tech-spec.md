# Prompt: Solutions Architect - Technical Specification

**Persona:** Solutions Architect
**Phase:** 1 - Planning and Design
**Purpose:** Translate a PRD into a detailed technical design/implementation plan

---

## When to Use This Prompt

✅ **Use when:**
- You have an approved PRD
- The feature is non-trivial (requires planning)
- You want to validate the architecture before writing code

❌ **Don't use when:**
- You don't have a PRD yet (use Product Owner first)
- The task is trivial (e.g., changing button text)
- You're ready to write code (use Specialist Developer)

---

## The Prompt Template

```markdown
You are a Solutions Architect. Your product manager has provided the attached PRD. Your task is to design the technical implementation.

**Rules:**
1. You MUST read and obey all rules in the attached `CONSTITUTION.md` file
2. You MUST read the attached `[feature-name]-prd.md` file
3. You MUST scan the current codebase (attached files) to find integration points
4. **CRITICAL: DO NOT WRITE SOURCE CODE.** You are to create the step-by-step *plan* and *design* only, not the implementation
5. State all assumptions clearly
6. If the PRD is unclear or missing critical information, ask clarifying questions

**Your Task:**
Create a technical specification document that details *how* to implement the PRD.

**The Tech Spec MUST include these sections:**

### 1. Proposed Architecture
- Which files will be **created**? (with file paths)
- Which files will be **modified**? (with file paths)
- High-level component interaction (how do they work together?)

### 2. Data Model / Schema Changes
- What database tables/collections need to be created or modified?
- What are the fields, types, and constraints?
- (If complex, say "See separate database schema prompt")

### 3. API Endpoints (if applicable)
- What endpoints need to be created/modified?
- What are the request/response formats?
- (If complex, say "See separate API design prompt")

### 4. Key Components/Functions
- What are the main functions or classes needed?
- What is the responsibility of each?
- What are the key algorithms or business logic?

### 5. Integration Points
- How does this feature connect to existing code?
- What existing services/modules will it use?
- What existing services/modules need to be modified?

### 6. Security Considerations
- What security measures are needed? (auth, input validation, encryption, etc.)
- Any OWASP concerns to address?

### 7. Error Handling
- What errors might occur?
- How should they be handled?
- What error messages should users see?

### 8. Testing Strategy
- What types of tests are needed? (unit, integration, E2E)
- What are the critical test cases?

### 9. Assumptions & Constraints
- What assumptions are you making?
- What constraints exist? (performance, tech stack, etc.)

**Output Format:**
- Save the tech spec in the `docs/` directory
- The filename must match the PRD name but with a `-tech-spec.md` suffix
- Example: If PRD is `docs/password-reset-prd.md`, tech spec is `docs/password-reset-tech-spec.md`

---

**Files to Attach:**
- `CONSTITUTION.md` (project standards)
- `[feature-name]-prd.md` (the requirement you're implementing)
- Relevant existing code files (for context and integration)

---

**PRD File:** [feature-name]-prd.md (attached)

**Existing Codebase Context:** [Attach relevant files]
```

---

## How to Use This Prompt

### Step 1: Prepare Your Inputs

Gather:
- [ ] The approved PRD
- [ ] `CONSTITUTION.md`
- [ ] Existing code files that this feature will touch or integrate with
  - Example: If adding auth, include existing auth code
  - Example: If adding API endpoint, include existing API route files

### Step 2: Attach Context Files

Critical files to attach:
- [ ] Database schema (if exists)
- [ ] API route files
- [ ] Service layer code
- [ ] Data models
- [ ] Configuration files

The more context, the better the tech spec.

### Step 3: Invoke the AI

Paste the prompt with all attached files.

### Step 4: Review the Tech Spec

Check for:
- [ ] Does the architecture make sense?
- [ ] Are there simpler approaches?
- [ ] Does it follow CONSTITUTION.md principles (simplicity, standards)?
- [ ] Does it over-engineer or under-engineer?
- [ ] Are integration points clearly identified?
- [ ] Are security considerations addressed?

### Step 5: Iterate if Needed

If something isn't right:
- Ask for alternatives: "Are there simpler ways to do this?"
- Request more detail: "Expand on the database schema section"
- Challenge assumptions: "Why did you choose approach X over Y?"

### Step 6: Optional - Use Specialized Prompts

For complex features, use specialized architect prompts:
- [1.3: Database Schema Design](./1.3-architect-database-schema.md)
- [1.4: API Endpoint Design](./1.4-architect-api-design.md)

---

## Example Input

```markdown
**PRD File:** password-reset-prd.md (attached)

**Existing Codebase Context:**
[Attach these files:]
- src/api/routes/auth.ts (existing auth routes)
- src/services/auth.service.ts (auth business logic)
- src/services/email.service.ts (email sending)
- src/models/user.model.ts (user data model)
- database/schema.sql (current database schema)
- CONSTITUTION.md
```

---

## Example Output (What the Architect Should Generate)

````markdown
# Technical Specification: Password Reset Feature

**File:** `docs/password-reset-tech-spec.md`

## 1. Proposed Architecture

### Files to CREATE:
- `src/api/routes/password-reset.ts` - New route handlers for reset endpoints
- `src/services/password-reset.service.ts` - Business logic for token generation/validation
- `src/utils/token-generator.ts` - Secure token generation utility
- `database/migrations/003_password_reset_tokens.sql` - Database migration

### Files to MODIFY:
- `src/api/routes/index.ts` - Register new password reset routes
- `src/models/user.model.ts` - Add password update method
- `src/services/email.service.ts` - Add password reset email template

### Component Interaction:
```
[User] → [POST /password-reset/request]
         ↓
    [PasswordResetController]
         ↓
    [PasswordResetService.createResetToken()]
         ↓
    [Database: Insert token] + [EmailService.sendResetEmail()]
         ↓
    [User receives email] → [Clicks link]
         ↓
    [GET /password-reset/verify?token=xxx]
         ↓
    [PasswordResetService.verifyToken()]
         ↓
    [User submits new password]
         ↓
    [POST /password-reset/confirm]
         ↓
    [PasswordResetService.resetPassword()]
         ↓
    [Update user password + Invalidate all sessions]
```

## 2. Data Model / Schema Changes

### New Table: `password_reset_tokens`
```sql
CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP NULL,
    CONSTRAINT token_not_expired CHECK (expires_at > created_at)
);

CREATE INDEX idx_password_reset_tokens_token_hash ON password_reset_tokens(token_hash);
CREATE INDEX idx_password_reset_tokens_user_id ON password_reset_tokens(user_id);
```

**Fields:**
- `token_hash`: Hashed version of reset token (security: never store plain tokens)
- `expires_at`: Token valid for 1 hour from creation
- `used_at`: Tracks if token was already used (prevents reuse)

## 3. API Endpoints

### Endpoint 1: Request Password Reset
**Method:** `POST`
**Path:** `/api/auth/password-reset/request`

**Request Body:**
```json
{
  "email": "user@example.com"
}
```

**Response (Success - 200):**
```json
{
  "message": "If that email exists, a reset link has been sent"
}
```

**Note:** Always return 200 even if email doesn't exist (prevents email enumeration)

### Endpoint 2: Verify Reset Token
**Method:** `GET`
**Path:** `/api/auth/password-reset/verify`

**Query Parameters:**
- `token` (string, required): The reset token from email

**Response (Success - 200):**
```json
{
  "valid": true,
  "email": "u***@example.com"  // Masked for security
}
```

**Response (Error - 400):**
```json
{
  "error": {
    "code": "INVALID_TOKEN",
    "message": "This reset link is invalid or expired"
  }
}
```

### Endpoint 3: Confirm Password Reset
**Method:** `POST`
**Path:** `/api/auth/password-reset/confirm`

**Request Body:**
```json
{
  "token": "abc123...",
  "new_password": "SecurePass123!"
}
```

**Response (Success - 200):**
```json
{
  "message": "Password successfully reset"
}
```

## 4. Key Components/Functions

### `PasswordResetService`

**Method:** `createResetToken(email: string): Promise<void>`
- Looks up user by email
- Generates secure random token (32 bytes, hex)
- Hashes token before storing (bcrypt)
- Saves to database with 1-hour expiration
- Sends email with reset link (background task)
- Rate limits: Max 3 requests per email per hour

**Method:** `verifyToken(token: string): Promise<{ valid: boolean, userId?: string }>`
- Looks up token by hash
- Checks if expired
- Checks if already used
- Returns user ID if valid

**Method:** `resetPassword(token: string, newPassword: string): Promise<void>`
- Verifies token (reuses verifyToken method)
- Validates new password (complexity requirements from CONSTITUTION.md)
- Hashes new password (bcrypt, 10 rounds)
- Updates user password
- Marks token as used
- Invalidates all user sessions
- Sends confirmation email

### `TokenGenerator`

**Method:** `generate(): string`
- Uses crypto.randomBytes(32)
- Returns hex string

**Method:** `hash(token: string): string`
- Uses bcrypt.hash()
- Returns hashed token for database storage

## 5. Integration Points

### Existing Services Used:
- `EmailService.send()` - Send reset and confirmation emails
- `UserModel.findByEmail()` - Look up user
- `UserModel.updatePassword()` - Update password (NEW method to add)
- `SessionService.invalidateAll(userId)` - Invalidate sessions

### Modifications Required:
- `src/models/user.model.ts`:
  - Add `updatePassword(userId, hashedPassword)` method
- `src/services/email.service.ts`:
  - Add email template for password reset
  - Add email template for confirmation

## 6. Security Considerations

1. **Token Security:**
   - Tokens are 32 bytes (256 bits) of cryptographic randomness
   - Tokens are hashed before storage (prevents DB compromise attack)
   - Tokens are single-use (marked as used after reset)
   - Tokens expire after 1 hour

2. **Rate Limiting:**
   - Max 3 reset requests per email per hour
   - Implemented at service layer

3. **Email Enumeration Prevention:**
   - Always return success message, even if email doesn't exist
   - Don't reveal if email is in system

4. **Password Validation:**
   - Enforce complexity requirements (per CONSTITUTION.md)
   - Min 12 characters, special chars required

5. **Session Invalidation:**
   - All user sessions invalidated on password reset
   - Forces re-login everywhere

6. **Input Validation:**
   - Email format validation
   - Password strength validation
   - Token format validation

## 7. Error Handling

### Possible Errors:
1. Invalid email format → 400 Bad Request
2. Invalid token → 400 Bad Request
3. Expired token → 400 Bad Request
4. Used token → 400 Bad Request
5. Weak password → 400 Bad Request
6. Email service failure → Log error, fail silently to user
7. Database errors → 500 Internal Server Error

### Error Response Format (per CONSTITUTION.md):
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "User-friendly message"
  }
}
```

## 8. Testing Strategy

### Unit Tests:
- `PasswordResetService.createResetToken()` - Verify token creation and email sending
- `PasswordResetService.verifyToken()` - Test valid/invalid/expired tokens
- `PasswordResetService.resetPassword()` - Test password update and session invalidation
- `TokenGenerator` - Test randomness and hashing

### Integration Tests:
- Full flow: Request → Verify → Confirm
- Rate limiting enforcement
- Database constraints (unique tokens, foreign keys)

### E2E Tests (Optional):
- User can reset password via email
- Expired link shows error
- Used link shows error

## 9. Assumptions & Constraints

### Assumptions:
1. Email service is reliable (or has retry logic)
2. Users have access to their email
3. Database supports UUIDs and bcrypt hashing
4. SMTP credentials are configured

### Constraints:
1. Tech stack: FastAPI (per CONSTITUTION.md)
2. Database: PostgreSQL (per CONSTITUTION.md)
3. Token expiration: 1 hour (hardcoded for v1)
4. Max reset requests: 3 per hour per email

### Performance Considerations:
1. Bcrypt hashing is CPU-intensive (acceptable for auth operations)
2. Email sending is async (doesn't block request)
3. Database queries use indexes for performance

---

**Next Steps:**
1. Review and approve this tech spec
2. Generate task list (see prompt 2.1)
3. Begin implementation

**Created:** 2025-11-14
**Status:** Ready for Review
````

---

## Tips for Better Tech Specs

### ✅ DO:
- Be specific about file paths
- Explain WHY, not just WHAT
- Consider security from the start
- Identify integration points
- State assumptions explicitly
- Include error handling

### ❌ DON'T:
- Write actual source code (that's Phase 2)
- Over-engineer for hypothetical future needs
- Ignore existing code patterns
- Skip security considerations
- Make undocumented assumptions

---

## Next Steps After Tech Spec Approval

1. **Save it** to `docs/[feature-name]-tech-spec.md`
2. **Optional:** Run specialized architect prompts if needed:
   - [1.3: Database Schema](./1.3-architect-database-schema.md)
   - [1.4: API Design](./1.4-architect-api-design.md)
3. **Move to Phase 2:** Generate task list
   - See [2.1: Generate Task List](../phase-2-implementation/2.1-generate-task-list.md)

---

## Related Resources

- [Solutions Architect Persona](../../personas/02-solutions-architect.md)
- Previous: [Product Owner - PRD](./1.1-product-owner-prd.md)
- Next: [Generate Task List](../phase-2-implementation/2.1-generate-task-list.md)
